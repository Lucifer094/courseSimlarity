《数据结构》是计算机专业本科学生的专业技术基础课。也是计算机程序设计的重要理论技术基础。它不仅是计算机学科的核心课程，而且已成为其他理工专业的热门选修课程。设置本课程的目的是要培养学生的数据抽象能力，学会分析研究计算机加工的数据结构的特性，以便为应用涉及的数据选择适当的逻辑结构、存储结构及实现应用的相应算法，并初步掌握分析算法的时间和空间复杂度的技术。学习本课程的要求是：通过本课程的学习，使学生了解和掌握数据结构和算法的基本思想和常见算法，学习分析、设计和实现解决问题的策略；使学生了解和基本掌握典型的数据结构类型及其应用；结合实际问题分析，加深对所学知识的理解，并为后续课程和未来的工程实践打下良好的基础。《数据结构》是计算机类各专业的一门必修的核心课程，从课程的地位来说，它在专业基础课和专业课之间起着承上启下的作用，应此一般安排在《离散数学》和《C语言程序设计》课程之后，后续课程还包括《面向对象程序设计》、《软件工程》等。通过本课程的学习，使学生能够系统地掌握数据结构的基本概念、各种数据结构的基本原理、适用场景和实现技术；具有使用数据结构解决实际应用的能力，为以后在学习其他课程以及实际工作打下坚实的理论基础。二、课程具体内容及基本要求第1章绪论(2学时)（一）基本内容：（1）什么是数据结构程序＝数据结构＋算法线性结构：1：1关系树线结构：1：N层次组织关系图状结构：N：N关系数据结构是一门研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作等的学科。（2）基本概念和术语数据：所有能输入到计算机中并能被计算机程序处理的符号的总称。如数值、字符、图像、声音等。数据元素：用于描述数据的基本单位。它可由数据项组成。数据项是数据表示中不可分割的最小标识单位。数据对象：具有相同性质的数据元素所组成的集合。数据对象中包含的数据元素之间具有一定的组织形式和结构关系。数据结构：是对数据元素及其相互关系的描述。包含两方面的内容：一方面是对数据元素的有限集合即数据对象的描述，另一方面是对数据对象中数据元素的关系的描述。数据结构的基本类型：集合、线性结构、树形结构、图状结构。数据的存储结构：与逻辑结构相对应。它指的是数据元素及其逻辑关系在计算机存储器中的存储形式，也称数据的物理结构。分为两类：顺序存储结构与非顺序存储结构（链式存储结构）。（3）抽象数据类型的表示与实现抽象数据类型通过固有数据类型来表示和实现，即利用处理器中已存在的数据类型来说明新的结构，用以实现的操作来组合新的操作。描述语言：类C语言。（4）算法和算法分析算法及其特性：算法是对特定问题的求解描述，它是指令的有限序列。算法通常有五个特性：有穷性、确定性、可行性、输入、输出。算法设计的要求：正确性、可读性、健壮性、效率与低存储量需求。算法效率的度量：时间复杂度和空间复杂度。（二）基本要求（1）熟悉数据、数据元素、数据对象、数据结构等名词、术语的含义，掌握基本概念，特别是数据的逻辑结构和存储结构之间的关系；（2）了解抽象数据类型的定义、表示和实现方法；（3）熟悉类C语言的书写规范，特别要注意值调用和引用调用的区别，输入、输出的方式以及错误处理方式；（4）理解算法五个要素的确切含义；（5）掌握计算语句频度和估算算法时间复杂度的方法。（三）重点、难点（1）数据的逻辑结构与存储结构的关系；（2）如何分清哪些是逻辑结构的性质，哪些是存储结构的性质；（3）算法的时间和空间复杂度分析。（四）作业及课外学习要求：（1）思考什么是数据、数据元素以、数据对象、数据结构、存储结构、数据类型和抽象数据类型？（2）试描述数据结构和抽象数据类型的概念与程序设计语言中数据类型概念的区别。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第2章线性表(6学时)（一）基本内容：（1）线性表的类型定义线性表是由n个数据元素所构成的一个有限序列，表中的每个数据元素都具有相同的数据类型，其中表中的每个数据元素也称为结点，结点与结点之间具有一定的前后次序关系，也即除了第一个结点以外，每一个结点都有一个前驱，除了最后一个结点以外，每个结点都有一个后继。线性表中数据元素的个数n称为线性表的长度，当n=0时，线性表就是一张空表。对于表中的每一个数据元素，它都有确定的位置，也就是该数据元素在表中的序号。线性表中的数据元素可由多个数据项构成，也可只包含一个数据项。每一个数据项也就相应地称为结点中的数据域。对于线性表而言，通常有以下基本操作：初始化、销毁、求长度、定位、插入元素、删除元素、取元素、求前驱、求后继、遍历等。这些操作都是定义在线性表的逻辑结构上的基本操作，在尚未对线性表的存储结构作出规定之前，这些操作的具体实现尚无法得到。（2）线性表的顺序表示和实现线性表的顺序存储结构指的是表中的结点依次存储在一组地址连续的存储单元中，使得结点的逻辑顺序与它在存储器中的物理顺序一致，这种结构的线性表也称为顺序表。假设线性表中的每个结点具有固定长度，占用m个存储单元，并且线性表中第一个结点的存储地址为Loc(a1)，则表中第i个结点的存储地址为：Loc(ai)=Loc(a1)+(i-1)*m线性表顺序存储结构的类型定义：在C语言中，实现线性表的顺序存储结构的类型定义#defineLIST_INIT_SIZE100//线性表存储空间的初始分配量#defineLISTINCREMENT10//线性表存储空间的分配增量typedefstruct{ElemType*elem;//指向存放线性表中数据元素的基地址intlength;//线性表的当前长度intlistsize;//当前分配的存储容量(以sizeof(ElemType)为单位）}SqList；线性表顺序存储结构下基本操作的实现算法：初始化操作、插入操作、删除操作。插入操作算法时间复杂度分析：平均移动元素次数为n/2，时间复杂度O(n)。删除操作算法：平均移动元素次数为(n-1)/2，时间复杂度O(n)。线性表的顺序存储结构的优点：简单、直观，易于实现随机存取。线性表的顺序存储结构的缺点：需要占据较大的连续存储空间，不利于零碎内存空间的利用，且在数据元素的插入和删除时，为了保证逻辑关系与物理位置的对应，必须要移动大量的数据元素。（3）线性表的链式表示和实现为了克服线性表顺序存储结构存在的缺点，在线性表的链式存储结构中，逻辑上相邻的数据元素不必在物理上也占据相邻的存储单元。这意味着可用物理上任意位置的存储单元来存储线性表中的数据元素。此时，数据元素的逻辑关系是通过指针来表示的。（a）线性链表由于在链式存储结构中，数据元素的逻辑关系是通过指针来表示的，因此，线性表中的基本单位除了要有存储数据元素的数据域外，还要有存储指示其与其他元素的逻辑关系的指针，这样的基本单位称为结点。线性链表中结点的结构为：datanext其中，data域为存储数据元素信息的数据域，而next则为指示其直接后继存储位置的指针域。如此，一个包含了n个结点的线性表(a1,a2,……an)就是一个线性链表，其结构如下图所示：a1a2┅┅An^其中，线性链表中的最后一个结点无直接后继，其指针域为空（NULL）。由于在这样的线性表结点中，只有一个指示相邻元素的指针域，因此又称为单链表。链表中结点之间的逻辑次序是通过指针来指示的，而结点在存储器中的存储位置可以是任意的，并不要求逻辑上相邻的数据元素在物理位置上也相邻。所以说，链式存储结构是非随机存储结构。为了确定线性链表中的第一个结点，在线性链表中设置一个指向第一个结点的特殊指针，称为头指针。这样，一个线性链表就可以由头指针唯一确定。在C语言中，线性链表的存储结构可定义如下：typedefstructLnode{//结点类型ElemTypedata;//结点的数据域内容structLnode*next;//指向后继结点的指针}Lnode,*LinkList为了便于线性链表的各种操作的算法实现，通常在线性表的第一个结点（首元结点）之前附设一个结点，称为头结点。头结点的结构与链表中的结点结构相同，它的指针域存储指向线性表中真正的第一个结点的指针，而数据域可按需要存储有关线性表的一些附加信息或不存储任何信息。线性表在附加了头结点后，头指针就指向线性表的头结点了，这样，对线性表中第一个结点的操作方法就变得与其他结点的操作方法一样了，从而使算法实现更加简洁。此时，判断线性表是否为空的标志就不再是看线性表的头指针是否为空值，而要看头结点的指针域是否为空。线性链表存储结构下基本操作的实现算法：插入操作算法（需要修改2个指针）、删除操作算法（需要修改1个指针）。与顺序存储结构相比，不需要移动数据元素。（b）循环链表在单链表中，只有单向指针（指向其直接后继），从某个结点出发只能查找其后的那些结点。如果要查找它前面的结点，就必须从表头结点开始搜索。而利用循环链表，在不增加存储空间的同理，可以实现从表中任意结点出发，访问表中其他所有结点，不必借助头指针。循环链表就是将单链表最后那个结点的后继指针改为指向其表头。在循环链表中，结点的存储结构与单链表中完全相同。其基本操作的实现也与单链表基本一致，其差别在于，判断当前结点是否为表中最后结点的条件，由原来的看后继指针是否为空，改为看其后继指针是否等于头指针。（c）双向链表在单链表中，结点的指针域只存放一个指向后继的指针，在这样的结构中，要寻找一个结点的前驱需要从表头开始进行查找，不太方便。可对其扩充，构造双向链表。在双向链表中，每个结点包含三个域：一个数据域和两个指针域。其中，一个指针域指向结点的后继，另一个结点指向它的前驱。结点的结构如下图所示。priordatanext在双向链表中，给定某个结点位置，既可以利用后继指针进行正向搜索，又可利用前驱指针进行逆向搜索，比单链表更便于结点的定位与插入。在实际应用中，利用双向链表常常可以获得很多便利。但是，双向链表与单向链表相比，需要更多的存储空间。在双向链表存储结构下，线性表的插入操作需要修改的指针数量为4，删除操作需要修改的指针数量为2。（4）线性表应用为了配合第一次的上机实验，线性表的应用以约瑟夫问题为例。【举例】约瑟夫问题描述：约瑟夫（Joseph）问题：编号为1，2，···，n的n个人按顺时针方向围坐在一张圆桌旁，每个人手中持有一个密码（正整数）。首先输入一个正整数作为报数上限值m，然后，从第一个人开始按顺时针方向自1开始顺序报数，报到m的人离开桌旁，并将他手中的密码作为新的m值，从顺时针方向的下一个就坐在桌旁的人人开始重新从1报数，如此下去，直至所有人全部离开桌旁为止。假设有7个人，编号从1到7，他们手中的密码分别是3，1，7，2，4，8，4，最初的m=2，通过报数，这7个人离开桌旁的顺序应该是：2，3，5，4，7，6，1。数据结构的分析：这个问题的主角是n个人，每个人需要描述的信息有：编号、密码和是否在桌旁的状态。假设有7个人，他们的信息可以表示成下面的形式。该问题中涉及的数据结构是典型的线性表结构，同样可以采用顺序存储和链式存储表示和实现。（二）基本要求（1）了解线性表的逻辑结构定义、抽象数据类型定义和各种存储结构的描述方法；（2）熟练掌握在线性表的两类存储结构（顺序存储和链式存储）上实现基本操作：查找、插入和删除算法；（3）熟练掌握在各种链表结构中实现线性表操作的基本方法，能在实际应用中选用适当的链表结构。（4）能够从时间和空间复杂度的角度综合比较线性表两种存储结构的不同特点及其适用场合。（三）重点、难点重点：(1)链表是本章的重点和难点，扎实的指针操作和内存动态分配技术是学好本章的基本要求；(2)链表中的头结点、头指针和首元结点的区别(3)线性链表、循环链表、双向链表的优缺点，在实际应用中加以合理的选用。(4)线性表插入和删除操作算法的时间和空间复杂度分析。难点：线性表的链式存储表示和基本操作的实现。（四）作业及课外学习要求：(1)已知长度为n的线性表A采用顺序存储结构，试设计算法，删除该线性表中所有值为item的数据元素。(2)已知长度为n的线性表A=(a1,a2,…..an)采用顺序存储结构，写一算法，将线性表转换为A=(an,……,a2,a1)，要求转换过程中使用用可能少的辅助空间。(3)已知长度为n的线性表A采用顺序存储结构，写一算法找出该线性表中值最小的数据元素。(4)已知L1和L2分别指向两个单链表的头结点，且已知其长度分别为m和n。试设计算法将这两个表连接在一起，并分析算法的时间复杂度。(5)假设在长度大于1的单循环链表中，既无头结点也无头指针。s为指向链表中某个结点的指针，试编写算法删除结点*s的直接前趋结点。(6)设计算法，在带头结点的单链表中寻找第i个结点。若找到，则函数返回第i个结点的地址。(7)给定(已生成)一个带表头结点的单链表，设head为头指针，结点的结构为(data,next),data为整型元素，next为指针，试写出算法:按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间。(要求：不允许使用数组作辅助空间)。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第3章栈和队列(6学时)（一）基本内容：（1）栈的类型定义及其结构特性栈：栈是指插入和删除都限定在表尾进行的线性表。从数据结构角度看，其特殊性在于栈的基本操作是线性表操作的子集，它是操作受限的线性表。如下图所描述：栈顶：在栈中允许插入、删除的表尾叫做栈顶。栈底：在栈中不允许插入、删除的表头叫做栈底。栈的结构特性：栈中元素被处理时，按照先进后出的顺序进行，所以栈又被称为后进先出（LIFO－LastInFirstOut）的线性表。栈的五种基本操作：（a）初始化：生成一个新的空栈；（b）进栈：向栈中压入一个新的元素，作为新的栈顶；（c）出栈：取得栈顶元素，并将其从栈中删除；（d）取栈顶元素：取得栈顶元素的值；（e）判空：判别一个栈是否为空。（2）栈的顺序存储结构栈的顺序存储结构简称顺序栈，利用一组地址连续的存储单元依次存放栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。顺序栈的类型定义：#defineSTACK_INIT_SIZE100;#defineSTACKINCREMENT10;typedefstruct{ElemType*base;//栈底指针ElemType*top;//栈顶指针intstactsize//指示栈当前可使用的最大容量}SqStack;栈的几种状态：（a）若base=NULL，则栈不存在；（b）栈的初始状态为top=base，即栈为空栈。（c）入栈状态为top增1，即top++;（d）出栈状态为top减1，即top--;无论栈处在何种状态，栈底指针base的位置始终不发生变化，始终指向栈底的位置。栈不存在base=NULL栈空base=top入栈top++出栈top--顺序栈的五种基本操作的实现算法。（3）栈的链式存储结构栈的链式存储结构简称链栈，链栈通常用一个无头结点的单链表表示。栈的链式存储结构在C语言中可用下列类型定义实现：typedefstructnode{//链栈的结点结构ElemTypedata;//栈的数据元素类型structnode*next;//指向后继结点的指针}NODE;typedefstruct{NODE*top;}LinkStack;我们经常将链栈用下图的形式描述：top^bottom（4）栈的应用【举例1】将从键盘输入的字符序列逆置输出。比如，从键盘上输入：tsetasisihT；算法将输出：Thisisatest。下面我们给出解决这个问题的完整算法。typedefcharElemType;voidReverseRead(){STACKS;//定义一个栈结构Scharch;InitStack(&S);//初始化栈while((ch=getchar())!=’\n’)//从键盘输入字符，直到输入换行符为止Push(&S,ch);//将输入的每个字符入栈while(!StackEmpty(S)){//依次退栈并输出退出的字符Pop(&S,&ch);putchar(ch);}putchar(‘\n’);}【举例2】十进制数值转换成二进制。使用展转相除法将一个十进制数值转换成二进制数值。即用该十进制数值除以2，并保留其余数；重复此操作，直到该十进制数值为0为止。最后将所有的余数反向输出就是所对应的二进制数值。比如：(692)10=(1010110100)2，其展转相除的过程如图所示：【举例3】检验表达式中的括号匹配情况。假设在一个算术表达式中，可以包含三种括号：圆括号“（”和“）”，方括号“[”和“]”和花括号“{”和“}”，并且这三种括号可以按任意的次序嵌套使用。比如，...[...{...}...[...]...]...[...]...(...)..。现在需要设计一个算法，用来检验在输入的算术表达式中所使用括号的合法性。算术表达式中各种括号的使用规则为：出现左括号，必有相应的右括号与之匹配，并且每对括号之间可以嵌套，但不能出现交叉情况。我们可以利用一个栈结构保存每个出现的左括号，当遇到右括号时，从栈中弹出左括号，检验匹配情况。在检验过程中，若遇到以下几种情况之一，就可以得出括号不匹配的结论。（a）当遇到某一个右括号时，栈已空，说明到目前为止，右括号多于左括号；（b）从栈中弹出的左括号与当前检验的右括号类型不同，说明出现了括号交叉情况；（c）算术表达式输入完毕，但栈中还有没有匹配的左括号，说明左括号多于右括号。（5）队列的定义队列特殊性在于限定插入在线性表的一端进行，删除在线性表的另外一端进行。如下图所示：（6）队列的链式表示和实现在用链式存储结构表示队列时，需要设置队头指针和队尾指针，以便指示队头结点和队尾结点。入队需要执行下面三条语句：s->next=NULL;rear->next=s;rear=s;下面是在C语言中，实现队列链式存储结构的类型定义：typestructQNode{//链式队列的结点结构ElemTypedata;//队列的数据元素类型structQNode*next;//指向后继结点的指针}QNode,*QueuePtr;typedefstruct{//链式队列QueuePtrfront;//队头指针QueuePtrrear;//队尾指针}LinkQueue;（7）队列的顺序表示和实现队列的顺序存储结构如下图所示：队列的顺序存储结构：(a)用一组连续的存储单元依次存放从队列头到队列尾的元素之外，需设两个指针front和rear分别指示队列头元素和尾元素的位置。(b)在C语言中为描述方便，约定：初始化建空队列时，令front=rear=0，每插入新的队列尾元素时，尾指针增1，每删除队列头元素时，头指针增1。(c)在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。（8）队列的应用【举例1】汽车加油站。随着城市里汽车数量的急速增长，汽车加油站也渐渐多了起来。通常汽车加油站的结构基本上是：入口和出口为单行道，加油车道可能有若干条。每辆车加油都要经过三段路程，第一段是在入口处排队等候进入加油车道；第二段是在加油车道排队等候加油；第三段是进入出口处排队等候离开。实际上，这三段都是队列结构。若用算法模拟这个过程，就需要设置加油车道数加2个队列。【举例2】模拟打印机缓冲区。在主机将数据输出到打印机时，会出现主机速度与打印机的打印速度不匹配的问题。这时主机就要停下来等待打印机。显然，这样会降低主机的使用效率。为此人们设想了一种办法：为打印机设置一个打印数据缓冲区，当主机需要打印数据时，先将数据依次写入这个缓冲区，写满后主机转去做其他的事情，而打印机就从缓冲区中按照先进先出的原则依次读取数据并打印，这样做即保证了打印数据的正确性，又提高了主机的使用效率。由此可见，打印机缓冲区实际上就是一个队列结构。【举例3】CPU分时系统。.在一个带有多个终端的计算机系统中，同时有多个用户需要使用CPU运行各自的应用程序，它们分别通过各自的终端向操作系统提出使用CPU的请求，操作系统通常按照每个请求在时间上的先后顺序，将它们排成一个队列，每次把CPU分配给当前队首的请求用户，即将该用户的应用程序投入运行，当该程序运行完毕或用完规定的时间片后，操作系统再将CPU分配给新的队首请求用户，这样即可以满足每个用户的请求，又可以使CPU正常工作。（二）基本要求(1)了解线性表的逻辑结构定义、抽象数据类型定义和各种存储结构的描述方法；(2)熟练掌握在线性表的两类存储结构（顺序存储和链式存储）上实现基本操作：查找、插入和删除算法；(3)熟练掌握在各种链表结构中实现线性表操作的基本方法，能在实际应用中选用适当的链表结构。(4)能够从时间和空间复杂度的角度综合比较线性表两种存储结构的不同特点及其适用场合。（三）重点、难点重点：（1）栈和队列是本章的重点和难点，扎实的指针操作和内存动态分配技术是学好本章的基本要求；（2）栈和队列中的头、尾的区别；（3）栈和队列的优缺点，在实际应用中加以合理的选用，。（4）栈和队列插入和删除操作算法的时间和空间复杂度分析。难点：循环队列的构造、插入、删除及判断队列的满与空的操作。（四）作业及课外学习要求：(a)栈和队列这两种数据结构的特性。(b)如何利用堆栈去模拟递归程序的运行。(c)假设以顺序存储结构实现一个双向栈，即在一维数组的存储空间中存在着两个栈，它们的栈底分别设在数组的两个端点。试编写算法实现这个双向栈tws的3个操作：初始化inistack(tws)、入栈push(tws,i,x)和出栈pop(tws,i)的算法，其中i为0或1，用以分别指示设在数组两端的两个栈。(d)在一个循环链队中只有尾指针（记为rear，结点结构为数据域data，指针域next），请给出这种队列的入队和出队操作的实现过程。(e)已知Q是一个非空队列，S是一个空栈。用队列和栈的基本操作函数和少量工作变量，编写一个算法，将队列Q中的所有元素逆置。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第4章串(6学时)（一）基本内容：（1）串类型的定义串是由零个或多个字符组成的有限序列。串、子串的定义。串的数据结构定义和实现。（2）串的表示和实现在程序设计语言中，如何在内存中表示。表示类型有：(a)定长顺序存储表示，结构定义：#defineMAXSTRLEN255TypedefunsignedcharSString[MAXSTRLEN+1];定长顺序存储表示的串的操作：串连接Concat(&T,S1,S2)求子串SubString(&Sub,S,pos,len)(b)堆分配存储表示,结构定义：Typedefstruct{Char*ch;Intlength;}HString;堆分配存储表示的串的操作：插入：StatusStrInsert(HString&S,intpos,HStringT)赋值：StatusStrAssign(HString&T,char*chars)返回字符长度：intStrLength(HStringS)清空：intStatusClearString(HString&S)连接：StatusConcat(HString&T,HStringS1,HStringS2)子串：StatusSubString(HString&Sub,HStringS,intpos,intlen)(c)串的块链存储表示,结构定义：#defineCHUNKSIZE80TypedefstructChunk{Charch[CHUNKSIZE];StructChunk*next;}Chunk;Typedefstruct{Chunk*head,*tail;Intcurlen;}LString;（3）串的模式匹配算法(a)求子串位置的定位函数Index(S,T,pos)。基本思想是:从主串S的第pos个字符起和模式的第一个字符比较之，若相等，则继续逐个比较后续字符；否则从主串的下一个字符起再重新和模式的字符比较之。(b)最快情况下时间复杂度是O（n*m）。(c)模式匹配的一种改进算法：KMP算法。算法复杂度是O（m）。（4）串操作应用举例。（二）基本要求(1)了解串的结构，定义，表示、实现，还有一些基本的匹配算法。(2)熟悉掌握串的内存分配表示和实现。（三）重点、难点重点：(1)了解串的特点。(2)了解串的几种实现方式。(3)了解几种方法的操作。(4)串的模式匹配算法。难点：(1)几种串的实现方法。(2)KMP算法的思想。（四）作业及课外学习要求：(1)实现一个完整的字符串的类，要求：实现完成的操作，包括插入，赋值，清空，定位子串等操作；考虑效率；考虑内存使用。(2)深入考虑KMP算法，看有没有进一步优化的可能性。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第5章数组与广义表(6学时)（一）基本内容：（1）数组的定义与基本操作数组的定义：数组的特点是每个数据元素可以又是一个线性表结构。若线性表中的数据元素为非结构的简单元素，则称为一维数组，即为向量；若一维数组中的数据元素又是一维数组结构，则称为二维数组；依次类推，若二维数组中的元素又是一个一维数组结构，则称作三维数组二维数组可以看成是这样一个定长线性表：它的每个数据元素也是一个定长的线性表。数组的基本操作：数组结构一般在创建时就确定了组成该结构的行向量数目和列向量数目，因此，在数组结构中不存在插入、删除元素的操作。二维数组结构的基本操作：给定一组下标，修改该位置元素的内容Assign(A,item,index1,index2)；给定一组下标，返回该位置的元素内容Value(A,item,index1,index2)。（2）数组的存储结构数组一般采用顺序存储结构，从理论上讲，数组结构也可以使用两种存储结构，即顺序存储结构和链式存储结构。然而，由于数组结构没有插入、删除元素的操作，所以使用顺序存储结构更为适宜。换句话说，一般的数组结构不使用链式存储结构。数组的存储表示：组成数组结构的元素可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。对于数组，一旦规定了它的维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。在C语言中数组的存储采用以行序为主序的存储结构。假设每个数据元素占L个存储单元，则上述二维数组A中任一元素aij的存储位置可由下式确定：LOC(i,j)=LOC(0,0)+(n*i+j)*L数组结构的定义：#defineMAX_ROW_INDEX10#defineMAX_COL_INDEX10typedefstruct{ElemTypeelem[MAX_ROW_INDEX][MAX_COL_INDEX];}Array;基本操作算法举例：（a）给数组元素赋值：voidAssign(Array*A,ElemTypeitem,intindex1,intindex2){if(index1<0||index1>=MAX_ROW_INDEX||index2<0||index2>=MAX_COL_INDEX)exit(ERROR);elseA->item[index1][index2]=item;}（b）返回给定位置的元素内容intValue(ArrayA,ElemType*item,intindex1,intindex2){if(index1<0||index1>=MAX_ROW_INDEX||index2<0||index2>=MAX_COL_INDEX)returnFALSE;else{*item=A.item[index1][index2];returnOK;}}（3）矩阵的压缩存储矩阵是在很多科学与工程计算中遇到的数学模型。在数学上，矩阵是这样定义的：它是一个由m×n个元素排成的m行（横向）n列（纵向）的表。(a)特殊矩阵所谓特殊矩阵就是元素值的排列具有一定规律的矩阵。常见的这类矩阵有：对称矩阵、下（上）三角矩阵、对角线矩阵等等。(b)对称矩阵对称矩阵的特点是aij=aji(c)下（上）三角矩阵其特点是以主对角线为界的上（下）半部分是一个固定的值，下（上）半部分的元素值没有任何规律。(d)对角矩阵其特点是所有的非零元素都集中在以主对角线为中心的带状区域中。对于这些特殊矩阵，应该充分利用元素值的分布规律，将其进行压缩存储。选择压缩存储的方法应遵循两条原则：一是尽可能地压缩数据量，二是压缩后仍然可以比较容易地进行各项基本操作。三种特殊矩阵的压缩方法：（a）对称矩阵对称矩阵的特点是aij=aji。一个n×n的方阵，共有n2个元素，而实际上在对称矩阵中有n(n-1)/2个元素可以通过其他元素获得。压缩的方法是首先将二维关系映射成一维关系，并只存储其中必要的n(n+1)/2个（主对角线和下三角）元素内容，这些元素的存储顺序以行为主序。（b）下（上）三角矩阵下三角矩阵的压缩存储与上面讲述的对称矩阵的压缩存储一样，只是将上三角部分的常量值存储在0单元，下三角和主对角上的元素从1号单元开始存放。（c）对角矩阵我们以三阶对角矩阵为例讨论一下它的压缩存储方法。对于对角矩阵，压缩存储的主要思路是只存储非零元素。这些非零元素按以行为主序的顺序，从下标为1的位置开始依次存放在一维数组中，而0位置存放数值0。(4)稀疏矩阵的压缩存储若一个m×n的矩阵含有t个非零元素，且t远远小于m*n，则我们将这个矩阵称为稀疏矩阵。(a)稀疏矩阵的压缩存储方法——三元组表示法。矩阵中的每个元素都是由行序号和列序号唯一确定的。因此，我们需要用三项内容表示稀疏矩阵中的每个非零元素，即形式为：(i,j,value)其中，i表示行序号，j表示列序号，value表示非零元素的值，通常将它称为三元。我们将稀疏矩阵中的所有非零元素用这种三元的形式表示，并将它们按以行为主的顺序存放在一个一维数组中，就形成了我们所说的三元组表示法。类型定义：#defineMAX_SIZE100最大的非零元素个数typedefstruct{inti,j;//行序号、列序号EntryTypevalue;//非零元素值}Three_Item;typedefstruct{Three_ItemItem[MAXSIZE];//存储非零元素的一维数组introws,cols,tu;//稀疏矩阵的总行数、列数及非零元素个数}Matrix;(b)矩阵的转置矩阵的转置是常见的一种矩阵运算。对于一个M*N的矩阵M，它的转置矩阵T是一个N*M的矩阵，且T(i,j)=M(j,i),1<=i<=n,1<=j<=m.一个稀疏矩阵的转置矩阵仍然是一个稀疏矩阵。如何求得矩阵M的转置矩阵T？①将矩阵的行列值相互交换；②将每个三元组中的i和j相互调换；③重排三元组之间的次序便可实现矩阵的转置。其中①和②是容易做到的，关键是③。即如何使b.item中的三元组是以T的行(M的列)为主序依次排列的。有两种处理方法：a)按照b.item中三元组的次序依次在a.item中找到相应的三元组进行转置。换句话说，按照矩阵M的列序来进行转置。为了找到M的每一列中所有的非零元素，需要对其三元组表a.item从第一行起整个扫描一遍，由于a.item是以M的行序为主序来存放每个非零元的，由此得到的恰是b.item应有的顺序。b)按照a.item中三元组的次序进行转置，并将转置后的三元组置入b中恰当的位置。这种方法称为矩阵的快速转置。如果能预先确定矩阵M中每一列(即T中每一行)的第一个非零元在b.item中应有的位置，那么在对a.item中的三元组依次作转置时，便可直接放到b.item中恰当的位置上去。为了确定这些位置，在转置前，应先求得M的每一列中非零元的个数，进而求得每一列的第一个非零元在b.item中应有的位置。需要附设num和cpot两个向量。num[col]表示矩阵M中第col列中非零元的个数，cpot[col]指示M中第col列的第一个非零元在b.data中的恰当位置。显然有：(5)广义表广义表的定义:广义表是线性表的推广的概念。广义表一般记作：LS=(a1,a2,…,an)其中LS为广义表的名称，n是长度。在线性表的定义中，ai只限于是单个元素，而在广义表的定义中，ai可是单个元素，也可广义表，分别称为LS的原子和子表。当广义表非空时，第一个元素称为LS的表头，称其余元素组成的表为LS的表尾。广义表试例：A=()A是一个空表，其长度为零B=(e)B是只有一个原子e，其长度为1C=(a,(b,c,d))C的长度为2，两个元素分别为原子a和子表(b,c,d)D=(A,B,C)D的长度为3,3个元素都是列表，将子表的值代入后，有D=((),(e),(a,(b,c,d)))E=(a,E)这是一个递归的表，它的长度为2。E相当于一个无限的列表E=(a,(a,(a,…)))广义表的特点:广义表的元素可以是子表，而子表的元素还可以是子表。广义表是一个多层次的结构。广义表可以其他广义表所共享，其可以通过子表的名称来引用。广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。任何一个非空的广义表其表头可能是原子，也可能是子表，而其表尾必定为子表。广义表的存储结构：广义表的链式存储结构:由于广义表中的元素可具有不同的结构，因此难以采用顺序存储结构表示，而通常采用链式存储结构，每个元素可用一个结点表示。结点结构:①表结点②原子结点类型定义:typedefemum{ATOM,LIST}ElemTag;typedefstructGLNode{ElemTagtag;//共公部分，用于区分原子和表结点union{//原子结点和表结点的联合部分AtomTypeatom;//原子结点的值域struct{structGLNode*hp,*tp;}ptr;//ptr是表结点的指针域，ptr.hp和ptr.tp分别指向表头和表尾};}*Glist;//广义表类型（二）基本要求(1)了解数组的两种存储表示方法，并掌握数组在以行为主序的存储结构中的地址计算方法；(2)掌握特殊矩阵压缩存储时的下标变换公式；(3)了解稀疏矩阵的两种压缩存储方法的特点和适用范围，领会以三元组表示稀疏矩阵时进行矩阵运算采用的处理方法；(4)掌握广义表的结构特点及其存储表示方法。（三）重点、难点重点：本章重点掌握数组在以行或列为主序的存储结构中的地址计算方法、特殊矩阵进行压缩存储时的下标变换公式和三元组表示稀疏矩阵情况下的矩阵运算。难点：三元组表示稀疏矩阵时进行矩阵运算(如矩阵的转置)采用的处理方法；（四）作业及课外学习要求：(1)假设有二维数组A[1..6,0..7]，每个元素用相邻的6个字节存储，存储器按字节编址。已知A的起始存储位置(基地址)为1000，计算：(1)数组A的体积(即存储量)；(2)数组A的最后一个元素A[6][7]的第一个字节的地址。(2)假设稀疏矩阵A和B均以三元组表作为存储结构。试写出矩阵相加的算法，另设三元组表C存放结果矩阵。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第6章树和二叉树(10学时)（一）基本内容：（1）树的定义和基本术语树的定义：树是一种常用的非线性结构。我们可以这样定义：树是n（n≥0）个结点的有限集合。若n=0，则称为空树；否则，有且仅有一个特定的结点被称为根，当n>1时，其余结点被分成m（m>0）个互不相交的子集T1，T2，...，Tm，每个子集又是一棵树。由此可以看出，树的定义是递归定义。常用术语：结点：数据元素的内容及其指向其子树根的分支统称为结点。结点的度：结点的分支数。终端结点（叶子）：度为0的结点。非终端结点：度不为0的结点。结点的层次：树中根结点的层次为1，根结点子树的根为第2层，以此类推。树的度：树中所有结点度的最大值。树的深度：树中所有结点层次的最大值。有序树、无序树：如果树中每棵子树从左向右的排列拥有一定的顺序，不得互换，则称为有序树，否则称为无序树。森林：是m（m≥0）棵互不相交的树的集合。在树结构中，结点之间的关系又可以用家族关系描述，定义如下：孩子、双亲结点：子树的根称为这个结点的孩子，而这个结点又被称为孩子的双亲。子孙：以某结点为根的子树中的所有结点都被称为是该结点的子孙。祖先：从根结点到该结点路径上的所有结点。兄弟：同一个双亲的孩子之间互为兄弟。堂兄弟：双亲在同一层的结点互为堂兄弟。（2）二叉树的定义和性质二叉树的定义：二叉树是另一种树形结构。它与树形结构的区别是：（a）每个结点最多有两棵子树；（b）子树有左右之分。二叉树也可以用递归的形式定义。即：二叉树是n（n≥0）个结点的有限集合。当n=0时，称为空二叉树；当n>0时，有且仅有一个结点为二叉树的根，其余结点被分成两个互不相交的子集，一个作为左子集，另一个作为右子集，每个子集又是一个二叉树。满二叉树：如果一个深度为K的二叉树拥有2K-1个结点，则将它称为满二叉树。完全二叉树：有一棵深度为h，具有n个结点的二叉树，若将它与一棵同深度的满二叉树中的所有结点按从上到下，从左到右的顺序分别进行编号，且该二叉树中的每个结点分别与满二叉树中编号为1－n的结点位置一一对应，则称这棵二叉树为完全二叉树。二叉树的性质：性质1：在二叉树的第i层上最多有2i-1个结点（i≥1）。性质2：深度为K的二叉树最多有2K-1个结点（K≥1）。性质3：对于任意一棵二叉树BT，如果度为0的结点个数为n0，度为2的结点个数为n2，则n0=n2+1。性质4：具有n个结点的完全二叉树的深度为log2n+1。其中，log2n的结果是不大于log2n的最大整数。性质5：对于有n个结点的完全二叉树中的所有结点按从上到下，从左到右的顺序进行编号，则对任意一个结点i（1≤i≤n），都有：如果i=1，则结点i是这棵完全二叉树的根，没有双亲；否则其双亲结点的编号为i/2。如果2i>n，则结点i没有左孩子(结点i为叶子结点)；否则其左孩子结点的编号为2i。如果2i+1>n，则结点i没有右孩子；否则其右孩子结点的编号为2i+1。（3）二叉树的存储结构二叉树也可以采用两种存储方式：顺序存储结构和链式存储结构。顺序存储结构:这种存储结构适用于完全二叉树。其存储形式为：用一组连续的存储单元按照完全二叉树的每个结点编号的顺序存放结点内容。链式存储结构:在顺序存储结构中，利用编号表示元素的位置及元素之间孩子或双亲的关系，因此对于非完全二叉树，需要将空缺的位置用特定的符号填补，若空缺结点较多，势必造成空间利用率的下降。在这种情况下，就应该考虑使用链式存储结构。（4）二叉树的遍历二叉树是一种非线性的数据结构，在对它进行操作时，总是需要逐一对每个数据元素实施操作，这样就存在一个操作顺序问题，由此提出了二叉树的遍历操作。所谓遍历二叉树就是按某种顺序访问二叉树中的每个结点一次且仅一次的过程。这里的访问可以是输出、比较、更新、查看元素内容等等各种操作。二叉树的遍历方式分为两大类：一类按根、左子树和右子树三个部分进行访问；另一类按层次访问。(a)按根、左和右子树三部分进行遍历。遍历二叉树的顺序存在下面6种可能：TLR（根左右）,TRL（根右左）LTR（左根右）,RTL（右根左）LRT（左右根）,RLT（右左根）其中，TRL、RTL和RLT三种顺序在左右子树之间均是先右子树后左子树，这与人们先左后右的习惯不同，因此，往往不予采用。余下的三种顺序TLR、LTR和LRT根据根访问的位置不同分别被称为先序遍历、中序遍历和后序遍历。先序遍历：若二叉树为空，则结束遍历操作；否则访问根结点；先序遍历左子树；先序遍历右子树。中序遍历：若二叉树为空，则结束遍历操作；否则中序遍历左子树；访问根结点；中序遍历右子树。（3）后序遍历若二叉树为空，则结束遍历操作；否则后序遍历左子树；后序遍历右子树；访问根结点。（b）按层次遍历二叉树。实现方法为从上层到下层，每层中从左侧到右侧依次访问每个结点。下面我们将给出一棵二叉树及其按层次顺序访问其中每个结点的遍历序列。（5）线索二叉树线索：n个结点的二叉链表中含有n+1个空指针域。利用二叉链表中的空指针域，存放指向结点在某种遍历次序下的前趋和后继结点的指针，这种附加的指针称为“线索”(Thread)。线索二叉树：加上了线索的二叉链表称为线索链表。相应的二叉树称为线索二叉树。(ThreadedBinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。线索链表的结点结构：线索链表中的结点结构为LchildLtagDataRtagRchild其中：ltag和rtag是增加的两个标志域，用来区分结点的左、右指针域是指向其左、右孩子的指针，还是指向其前趋或后继的线索。二叉树的线索化线索化实质：将二叉树变为线索二叉树的过程称为线索化。按某种次序将二叉树线索化的实质是：按该次序遍历二叉树，在遍历过程中用线索取代空指针。（6）树的存储结构双亲表示法：假设以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲在链表中的位置。类型定义：#defineMAX_TREE_NODE_SIZE100typedefstruct{TEntryTypeinfo;intparent;}ParentNode;typedefstruct{ParentNodeitem[MAX_TREE_NODE_SIZE];intn;//树中当前的结点数目}ParentTree;树的双亲表示法主要描述的是结点的双亲关系。这种存储方法的特点是寻找结点的双亲很容易，但寻找结点的孩子比较困难。孩子表示法：由于树中每个结点可能有多棵子树，则可用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，此时链表中的结点可以有如下两种结点格式：DataChild1Child2…ChilddDataDegreeChild1Child2…childd在C语言中，这种存储形式定义如下：#defineMAX_TREE_NODE_SIZE10typedefstructChildNode{intchild;//该孩子结点在一维数组中的下标值structChileNode*next;//指向下一个孩子结点}CNode;typedefstruct{TEntryTypeinfo;//结点信息CNode*firstchild;//指向第一个孩子结点的指针}TNode;typedefstruct{TNodeitem[MAX_TREE_NODE_SIZE];intn,root;//n为树中当前结点的数目，root为根结点在一维数组中的位置}ChildTree;这种存储结构的特点是寻找某个结点的孩子比较容易，但寻找双亲比较麻烦，所以，在必要的时候，可以将双亲表示法和孩子表示法结合起来，即将一维数组元素增加一个表示双亲结点的域parent，用来指示结点的双亲在一维数组中的位置。孩子兄弟表示法：也称二叉树表示法，或二叉链表表示法。即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点。孩子兄弟表示法也是一种链式存储结构。它通过描述每个结点的一个孩子和兄弟信息来反映结点之间的层次关系，其结点结构为：FirstchildItemnestsibling其中，firstchild为指向该结点第一个孩子的指针，nextsibling为指向该结点的下一个兄弟，item是数据元素内容。在C语言中，这种存储形式定义如下：typedefstructCSNode{EntryTypeitem;structCSNode*firstchild,*nextsibling;}CSNode,*CSTree;（7）森林与二叉树的转换（a）树、森林转换成二叉树将一棵树转换成二叉树的方法：将一棵树转换成二叉树实际上就是将这棵树用孩子兄弟表示法存储即可，此时，树中的每个结点最多有两个指针：一个指针指向第一个孩子，另一个指针指向右侧第一个兄弟。当你将这两个指针看作是二叉树中的左孩子指针和孩子右指针时，就是一棵二叉树了。将森林转换成二叉树的方法与一棵树转换成二叉树的方法类似，只是把森林中所有树的根结点看作兄弟关系，并对其中的每棵树依依地进行转换。（b）二叉树还原成树或森林这个过程实际上是树、森林转换成二叉树的逆过程，即将该二叉树看作是树或森林的孩子兄弟表示法。比如，若二叉树为空，树也为空；否则，由二叉树的根结点开始，延右指针向下走，直到为空，途经的结点个数是相应森林所含树的棵数；若某个结点的左指针非空，说明这个结点在树中必有孩子，并且从二叉树中该结点左指针所指结点开始，延右指针向下走，直到为空，途经的结点个数就是这个结点的孩子数目。（8）树和森林的遍历先根(次序)遍历树：若树不空，则先访问根结点，然后依次从左到右先根遍历根的各棵子树；后根(次序)遍历树：若树不空，则先依次从左到右后根遍历根的各棵子树，然后访问根结点；按层次遍历:若树不空，则自上而下自左至右访问树中每个结点。森林是树的集合，由此可以对森林中的每一棵树依次从左到右进行先根遍历或者后根遍历。又森林中的（第一棵树的根）、（第一棵树的子树森林）及（其余树构成的森林），分别对应为（二叉树的根）、（二叉树的左子树）和（二叉树的右子树）。由此可如下定义森林的这两种遍历。（a）先序遍历森林若森林不空，则可依下列次序进行遍历访问森林中第一棵树的根结点；先序遍历第一棵树中的子树森林；先序遍历除去第一棵树之后剩余的树构成的森林。（b）中序遍历森林若森林不空，则可依下列次序进行遍历：中序遍历第一棵树中的子树森林；访问森林中第一棵树的根结点；中序遍历除去第一棵树之后剩余的树构成的森林。（9）哈夫曼树及其应用（a）最优二叉树（哈夫曼树）在二叉树中，一个结点到另一个结点之间的分支构成这两个结点之间的路径。在路径上的分支数目被称为路径长度。用公式可表示为：带权的路径长度最小的二叉树称为哈夫曼二叉树或最优二叉树。构造哈夫曼树的过程：（1）将给定的n个权值{w1,w2,...,wn}作为n个根结点的权值构造一个具有n棵二叉树的森林{T1,T2,...,Tn}，其中每棵二叉树只有一个根结点；（2）在森林中选取两棵根结点权值最小的二叉树作为左右子树构造一棵新二叉树，新二叉树的根结点权值为这两棵树根的权值之和；（3）在森林中，将上面选择的这两棵根权值最小的二叉树从森林中删除，并将刚刚新构造的二叉树加入到森林中；（4）重复上面（2）和（3），直到森林中只有一棵二叉树为止。这棵二叉树就是哈夫曼树。（b）哈夫曼编码在传送电文时，希望总长尽可能的短。如果对每个字符设计长度不等的编码，且让电文中出现次数最多的字符采用尽可能短的编码，则传送电文的总长便可减少。此时则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称为前缀编码。而设计总长最短的二进制前缀编码即为以n中字符出现的频率作权，设计一棵哈夫曼树的问题。由此得到的二进制前缀编码便称为哈夫曼编码。（二）基本要求(1)熟练掌握二叉树的结构特性或性质，了解相应的证明方法；(2)熟悉二叉树的各种存储结构的特点及适用范围；(3)熟练掌握二叉树的遍历。不仅要熟练掌握各种遍历策略的递归和非递归算法，了解遍历过程中“栈”的作用和状态，而且能灵活运用遍历算法实现二叉树的其它操作。另外，层次遍历是按另一种搜索策略进行的遍历。(4)理解线索二叉树的实质是建立结点与其在相应序列中的前驱或后继之间的直接联系，熟练掌握二叉树的线索化过程以及在中序线索化树上找给定结点的前驱和后继的方法。(5)熟悉树的各种存储结构及其特点，掌握树和森林与二叉树的转换方法。树的存储结构是进行其它操作的基础，应熟练掌握树的孩子兄弟表示法及其上的各种操作(如树的遍历)。(6)了解最优树的特性，掌握建立最优树和哈夫曼编码的方法。（三）重点、难点重点：(1)二叉树的性质及证明方法；(2)二叉树的遍历及其基础上实现的其它操作；(3)线索二叉树的实质；(4)树、森林与二叉树的转换；(5)哈夫曼树(或最优二叉树)的特点及其构造。难点：(1)二叉树性质的证明过程；(2)二叉树的遍历及其算法；(3)树、森林与二叉树的转换；(4)线索二叉树；(5)哈夫曼树及哈夫曼编码。（四）作业及课外学习要求：(1)已知二叉树的前序序列和中序序列能否唯一确定一棵二叉树？已知二叉树的后序序列和中序序列能否唯一确定一棵二叉树？已知二叉树的前序序列和后序序列能否唯一确定一棵二叉树？(2)一棵前序序列为1，2，3，4，的二叉树，其中序序列可能是4，1，2，3吗？设一棵二叉树的前序序列为1，2，3，4，5，6，7，8，9，其中序序列为2，3，1，5，4，7，8，6，9，试画出该二叉树。(3)编写算法判断一棵二叉树是否是完全二叉树。(4)编写计算二叉树的最大宽度的算法（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。(5)试将下列三棵树组成的森林转换成对应的二叉树。(6)编写复制一棵二叉树的非递归算法。(7)对以孩子-兄弟表示法，编写树的层次遍历算法。(8)对以孩子-兄弟表示法，编写计算树的深度的算法。(9)证明：在结点数多于1的哈夫曼树中不存在度为1的结点。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第7章图(12学时)（一）基本内容：1图的定义和术语定义：图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。术语：数据对象、数据关系、基本操作、有向图、无向图、完全图、连通分量、连通图、路径、度、生成森林等等。2图的存储结构2.1邻接矩阵(1)有向图的邻接矩阵具有n个顶点的有向图可以用一个nn的方形矩阵表示。假设该矩阵的名称为M，则当<vi,vj>是该有向图中的一条弧时，M[i,j]=1；否则M[i,j]=0。第i个顶点的出度为矩阵中第i行中“1”的个数；入度为第i列中“1”的个数，并且有向图弧的条数等于矩阵中“1”的个数。(2)无向图的邻接矩阵具有n个顶点的无向图也可以用一个nn的方形矩阵表示。假设该矩阵的名称为M，则当（vi,vj）是该无向图中的一条边时，M[i,j]=M[j,i]=1；否则，M[i,j]=M[j,j]=0。第i个顶点的度为矩阵中第i行中“1”的个数或第i列中“1”的个数。图中边的数目等于矩阵中“1”的个数的一半，这是因为每条边在矩阵中描述了两次。2.2邻接表（1）边结点的结构：adjvexnext其中，adjvex是该边或弧依附的顶点在数组中的下标，next是指向下一条边或弧结点的指针。（2）项点结构itemfirstedge其中，item是顶点内容，firstedge是指向第一条边或弧结点的指针。在C语言中，实现邻接表表示法的类型定义如下所示：#defineMAX_VERTEX_NUM30//最大顶点个数typestructEdgeNode{//边结点intadjvex;structEdgeNode*next;}EdgeNode;typedefstructVexNode{//顶点结点EntryTypeitem;EdgeNode*firstedge;}VexNode,AdjList[MAX_VERTEX_NUM];本节讨论：邻接表与邻接矩阵有什么异同之处？联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。区别：①对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。②邻接矩阵的空间复杂度为O(n2),而邻接表的空间复杂度为O(n+e)。用途：邻接矩阵多用于稠密图的存储（e接近n(n-1)/2)；而邻接表多用于稀疏图的存储（e<<n2)3图的遍历图的遍历：从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程称为图的遍历。图的遍历是求解图的连通性问题、拓扑排序和求关键路径等问题的基础。常见的图遍历方式有两种：深度优先遍历和广度优先遍历，这两种遍历方式对有向图和无向图均适用。3.1深度优先遍历(depth-firstsearch)深度优先搜索遍历类似于树的先序遍历。假定给定图G的初态是所有顶点均未被访问过，在G中任选一个顶点i作为遍历的初始点，则深度优先搜索遍历可定义如下：(1)首先访问顶点i，并将其访问标记置为访问过，即visited[i]=1；(2)然后搜索与顶点i有边相连的下一个顶点j，若j未被访问过，则访问它，并将j的访问标记置为访问过，visited[j]=1，然后从j开始重复此过程，若j已访问，再看与i有边相连的其它顶点；(3)若与i有边相连的顶点都被访问过，则退回到前一个访问顶点并重复刚才过程，直到图中所有顶点都被访问完为止。3.2广度优先遍历(width-firstsearch)广度优先搜索遍历类似于树的按层次遍历。设图G的初态是所有顶点均未访问，在G中任选一顶点i作为初始点，则广度优先搜索的基本思想是：(1)首先访问顶点i，并将其访问标志置为已被访问，即visited[i]=1；(2)接着依次访问与顶点i有边相连的所有顶点W1，W2，…，Wt；(3)然后再按顺序访问与W1，W2，…，Wt有边相连又未曾访问过的顶点；依此类推，直到图中所有顶点都被访问完为止。4无向图的连通分量与生成树若图是连通的或强连通的，则从图中某一个顶点出发可以访问到图中所有顶点；若图是非连通的或非强连通图，则需从图中多个顶点出发搜索访问而每一次从一个新的起始点出发进行搜索过程中得到的顶点访问序列恰为每个连通分量中的顶点集。生成树是一个极小连通子图，它含有图中全部顶点，但只有n-1条边。深度优先搜索遍历算法及广度优先搜索遍历算法中遍历图过程中历经边的集合和顶点集合一起构成连通图的极小连通子图。它是连通图的一颗生成树。由深度优先搜索遍历得到的生成树，称为深度优先生成树，由广度优先搜索遍历得到的生成树，称为广度优先生成树。5最小生成树n个顶点的生成树很多，需要从中选一棵代价最小的生成树，即该树各边的代价之和最小。此树便称为最小生成树MST(MinimumcostSpanningTree)构造最小生成树的方法：最初生成树为空，即没有一个结点和一条边，首先选择一个顶点作为生成树的根，然后每次从不在生成树中的边中选择一条权值尽可能小的边，为了保证加入到生成树中的边不会造成回路，与该边邻接的两个顶点必须一个已经在生成树中，求最小生成树的两种方法：普里姆算法和克鲁斯卡尔算法普里姆算法：算法思想：最初生成树为空，即没有一个结点和一条边，首先选择一个顶点作为生成树的根，然后每次从不在生成树中的边中选择一条权值尽可能小的边，为了保证加入到生成树中的边不会造成回路，与该边邻接的两个顶点必须一个已经在生成树中，一个则不在生成树中，若网中有n个顶点（这里考虑的网是一个连通无向图），则按这种条件选择n-1边就可以得到这个网的最小生成树了。详细的过程可以描述为：设置2个集合，U集合中的元素是在生成树中的结点，V-U集合中的元素是不在生成树中的顶点。首先选择一个作为生成树根结点的顶点，并将它放入U集合，然后在那些一端顶点在U集合中，而另一端顶点在V-U集合中的边中找一条权最小的边，并把这条边和那个不在U集合中的顶点加入到生成树中，即输出这条边，然后将其顶点添加到U集合中，重复这个操作n-1次。克鲁斯卡尔算法：算法思想：将图中所有边按权值递增顺序排列，依次选定取权值较小的边，但要求后面选取的边不能与前面选取的边构成回路，若构成回路，则放弃该条边，再去选后面权值较大的边，n个顶点的图中，选够n-1条边即可。6拓扑排序6.1.定义给出有向图G=(V,E)，对于V中的顶点的线性序列(vi1,vi2,...,vin)，如果满足如下条件：若在G中从顶点vi到vj有一条路经，则在序列中顶点vi必在顶点vj之前；则称该序列为G的一个拓扑序列（Topologicalorder）构造有向图的一个拓扑序列的过程称为拓扑排序（Topologicalsort）6.2.说明(1)在AOV网中,若不存在回路,则所有活动可排成一个线性序列,使得每个活动的所有前驱活动都排在该活动的前面,那么该序列为拓扑序列.(2)拓扑序列不是唯一的.(3)对AOV网不一定都有拓扑序列.在AOV网中，<i,j>有向边表示i活动应先于j活动开始，即i活动必须完成后，j活动才可以开始，并称i为j的直接前驱，j为i的直接后继。这种前驱与后继的关系有传递性，此外，任何活动i不能以它自己作为自己的前驱或后继，这叫做反自反性。从前驱和后继的传递性和反自反性来看，AOV网中不能出现有向回路(或称有向环)。在AOV网中如果出现了有向环，则意味着某项活动应以自己作为先决条件，这是不对的，工程将无法进行。对程序流程而言，将出现死循环。因此，对给定的AOV网，应先判断它是否存在有向环。判断AOV网是否有有向环的方法是对该AOV网进行拓扑排序，将AOV网中顶点排列成一个线性有序序列，若该线性序列中包含AOV网全部顶点，则AOV网无环，否则，AOV网中存在有向环，该AOV网所代表的工程是不可行的。6.3拓扑排序算法。7关键路径7.1AOE网概念定义：若在带权的有向图中,以顶点表示事件,有向边表示活动,边上的权值表示完成该活动的开销(如该活动所需的时间),则称此带权的有向图为用边表示活动的网络,简称AOE网(ActivityOnEdge)说明：(1)AOV网与AOE网有密切关系又有不同。如果用他们表示工程，AOV网表示各个子工程之间的优先关系，是定性关系；在AOE网中还要体现完成各个子工程的确切时间，是定量关系。对于AOE网，我们关心的问题是：（A）完成整个工程至少需要多少时间？（B）哪些活动是关键活动：哪些活动的进度是影响整个工程进度的关键？(2)在AOE网中，只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。只有在进入每顶点的各有向边所代表的活动都已经结束后，该顶点所代表的事件才能发生。(3)在一个表示工程的AOE网中，应该不存在回路，网中仅存在一个入度为零的顶点，乘作开始顶点，它表示了整个工程的开始；网中仅存在一个出度为零的顶点，称为结束顶点，它表示整个工程的结束。7.2关键路径有关术语路径长度：AOE网中一条路径的长度是该路径上个活动所需时间的总和。关键路径：AOE网中,从开始顶点到结束顶点之间路径长度中的最大路径为关键路径。由于AOE网中某些子工程（活动）可以同时进行，要保证每个子工程都能完成，完成该工程的最少时间就是该工程AOE网的关键路径长度。事件的最早发生时间：事件vi的最早发生时间ve(i)是从开始顶点v到vi的最长路径长度。活动的最早开始时间：活动aj的最早开始时间e(j)是该活动的起点所表示的事件最早发生时间,如果由边(vi,vk)表示活动aj,则有e(j)=ve(i)。事件的最迟发生时间：事件vk的最迟发生时间vl(k)是在不推迟整个工程完成(即保证结束顶点vn在ve(n)时刻发生)的前提下,该事件最迟必须发生的时间。vl（k）为ve（n）减去顶点vk到结束顶点vn的最长路径的长度。活动的最迟开始时间：活动aj的最迟开始时间l(j)是该活动的终点所表示的事件最迟发生时间与该活动的所需时间之差。如果由边(vi,vk)表示活动aj,则有l(j)=vl（k）-aj所需时间。时间余量：活动aj的l(j)-e(j)是该活动完成的时间余量。它是在不增加完成整个工程所需时间的情况下，活动aj可以拖延的时间。关键活动：当一活动的时间余量=0，说明该活动必须如期完成，否则就会拖延完成整个工程的进度。若活动aj的时间余量=0，则称该活动为关键活动。当时间余量〉0，活动aj不是关键活动，只要拖延的时间不超过时间余量，就不会影响整个工程的进度；但如果拖延的时间超过时间余量，则关键活动就可能发生变化。7.3关键路径的求解过程与算法。8最短路径问题8.1单源最短路径—用Dijkstra（迪杰斯特拉）算法单源点最短路径是指：给定一个出发点(单源点)和一个有向网G=(V，E),求出源点到其它各顶点之间的最短路径。迪杰斯特拉(Dijkstra)提出了按路径长度递增序产生各顶点的最短路径算法,我们称之为迪杰斯特拉算法。算法的基本思想是：把图中顶点集合分成两组，第一组为集合S，存放已求出其最短路径的顶点，第二组为尚未确定最短路径的顶点集合是V-S（用U表示），其中V为网中所有顶点集合。按最短路径长度递增的顺序逐个把U中的顶点加到S中，直到S中包含全部顶点，而U为空。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。算法的具体步骤：（1）初始时，S只包含源点，S={v}，v的距离为0。U包含除v外的其他顶点，U中顶点的距离为顶点的权或∞。（2）从U中选取一个距离最小的顶点k，把k加入到S中。（3）以k作为新考虑的中间点，修改U中各顶点的距离。（4）重复步骤（2）、（3）直到所有顶点都包含在S中。8.2所有顶点间的最短路径—用Floyd（弗洛伊德）算法所有顶点间的最短路径是指：给定一个有向网G=(V，E),求出其中任意两点之间的最短路径。（二）基本要求熟悉图的定义和术语，掌握图的邻接矩阵存储结构和邻接矩阵存储结构，理解图的遍历操作，了解图的几个典型问题。（三）重点、难点本章是课程的重点内容之一，且内容较多。(1)图的两种遍历策略：深度优先搜索和广度优先搜索；(2)求解最小生成树；(3)求解关键路径；(4)图的两类最短路径问题的解法。（四）作业及课外学习要求：(1)试基于图的深度优先搜索策略写一算法，判别以邻接表方式存储的有向图中是否存在由顶点Vi到顶点Vj的路径(i不等于j)。(2)试基于图的广度优先搜索策略写一算法，判别以邻接表方式存储的有向图中是否存在由顶点Vi到顶点Vj的路径(i不等于j)。(3)给出图G：（1）画出G的邻接表表示图；（2）根据你画出的邻接表，以顶点①为根，画出G的深度优先生成树和广度优先生成树。(4)已知一个无向图如下图所示，要求分别用Prim和Kruskal算法生成最小树（假设以①为起点，试画出构造过程）。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第8章查找(8学时)（1）基本内容1静态查找表静态查找表：若只对查找表进行如下两种操作：（1）在查找表中查看某个特定的数据元素是否在查找表中，（2）检索某个特定元素的各种属性，则称这类查找表为静态查找表。静态查找表在查找过程中查找表本身不发生变化。对静态查找表进行的查找操作称为静态查找。1.1顺序表的查找基本思想：是将查找表作为一个线性表，可以是顺序表，也可以是链表，依次用查找条件中给定的值与查找表中数据元素的关键字值进行比较，若某个记录的关键字值与给定值相等，则查找成功，返回该记录的存储位置，反之，若直到最后一个记录，其关键字值与给定值均不相等，则查找失败，返回查找失败标志。1.2有序表的查找基本思想是：首先以整个查找表作为查找范围，用查找条件中给定值k与中间位置结点的关键字比较，若相等，则查找成功，否则，根据比较结果缩小查找范围，如果k的值小于关键字的值，根据查找表的有序性可知查找的数据元素只有可能在表的前半部分，即在左半部分子表中，所以继续对左子表进行折半查找；若k的值大于中间结点的关键字值，则可以判定查找的数据元素只有可能在表的后半部分，即在右半部分子表中，所以应该继续对右子表进行折半查找。每进行一次折半查找，要么查找成功，结束查找，要么将查找范围缩小一半，如此重复，直到查找成功或查找范围缩小为空即查找失败为止。1.3索引顺序表的查找在建立顺序表的同时，建立一个索引。索引顺序表=索引+顺序表2动态查找表有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其“查询”结果为“在查找表中”的数据元素。2.1二叉排序树在二叉排序树中进行查找的过程和二分查找类似，也是一个逐步缩小查找范围的过程。若查找成功，则是走了一条从根结点到待查结点的路径；若查找失败，则是走了一条根结点到某个叶子结点的路径。因此，查找过程中和关键字比较的次数不超过树的深度。由于含有n个结点的二叉排序树不唯一，形态和深度可能不同。故含有n个结点的二叉排序树的平均查找长度和树的形态有关。最好的情况是：二叉排序树和二叉判定树形态相同。最坏的情况是：二叉排序树为单支树，这时的平均查找长度和顺序查找时相同。就平均性能而言，二叉排序树上的查找和二分查找相差不大，并且二叉排序树上的插入和删除结点十分方便，无须大量移动结点。2.2平衡二叉树1）如果建立的二叉查找树的左右子树深度之差的绝对值不超过1，则称为平衡二叉树2）最佳二叉查找树就是平均查找长度最短的二叉查找树，它的结点构成上的特点是：除了最下一层可以不满外，其他各层都是充满了的。2.3B－树和B＋树(1)B－树B-树是一种平衡的多路查找树：在m阶的B-树上，每个非终端结点可能含有：n个关键字Ki（1≤i≤n）n<mn个指向记录的指针Di（1≤i≤n）n+1个指向子树的指针Ai（0≤i≤n）;B-树结构的C语言描述如下:typedefstructBTNode{intkeynum;//结点中关键字个数，结点大小structBTNode*parent;//指向双亲结点的指针KeyTypekey[m+1];//关键字（0号单元不用）structBTNode*ptr[m+1];//子树指针向量Record*recptr[m+1];//记录指针向量}BTNode,*BTree;//B树结点和B树的类型B-树特点：(1)非叶结点中的多个关键字均自小至大有序排列，即：K1<K2<…<Kn;且Ai-1所指子树上所有关键字均小于Ki;(2)Ai所指子树上所有关键字均大于Ki;(3)树中所有叶子结点均不带信息，且在树中的同一层次上;(4)根结点或为叶子结点，或至少含有两棵子树;(5)其余所有非叶结点均至少含有ém/2ù棵子树，至多含有m棵子树;查找过程：从根结点出发，沿指针搜索结点和在结点内进行顺序（或折半）查找两个过程。交叉进行。若查找成功，则返回指向被查关键字所在结点的指针和关键字在结点中的位置。若查找不成功，则返回插入位置。(2)B+树是B-树的一种变型。B+树的结构特点：每个叶子结点中含有n个关键字和n个指向记录的指针；并且，所有叶子结点彼此相链接构成一个有序链表，其头指针指向含最小关键字的结点；每个非叶结点中的关键字Ki即为其相应指针Ai所指子树中关键字的最大值；所有叶子结点都处在同一层次上，每个叶子结点中关键字的个数均介于m/2和m之间。查找过程：在B+树上，既可以进行缩小范围的查找，也可以进行顺序查找；在进行缩小范围的查找时，不管成功与否，都必须查到叶子结点才能结束；若在结点内查找时，给定值≤Ki，则应继续在Ai所指子树中进行查找；3哈希查找3.1哈希表的概念哈希函数：我们将记录的关键字值与记录的存储位置对应起来的关系H称为哈希函数，H(k)的结果称为哈希地址。哈希表：是根据哈希函数建立的表，其基本思想是：以记录的关键字值为自变量，根据哈希函数，计算出对应的哈希地址，并在此存储该记录的内容。哈希查找：当对记录进行查找时，再根据给定的关键字值，用同一个哈希函数计算出给定关键字值对应的存储地址，随后进行访问。所以哈希表即是一种存储形式，又是一种查找方法，通常将这种查找方法称为哈希查找。冲突：通常关键码的集合比哈希地址集合大得多，因而经过哈希函数变换后，可能将不同的关键码映射到同一个哈希地址上，我们将这种情况称为冲突，具有相同函数值的关键字值称为同义词。3.2哈希函数的构造直接定址法质数取余法平方取中法折叠法3.3解决冲突的方法开放定址法链地址法再哈希法公共溢出区法3.4哈希表查找及其分析哈希表的查找过程与哈希表的构造过程基本一致，对于给定的关键字值k，按照建表时设定的哈希函数求得哈希地址；若哈希地址所指位置已有记录，并且其关键字值不等于给定值k,则根据建表时设定的冲突处理方法求得同义词的下一地址，直到求得的哈希地址所指位置为空闲或其中记录的关键字值等于给定值k为止；如果求得的哈希地址对应的内存空间为空闲，则查找失败；如果求得的哈希地址对应的内存空间中的记录关键字值等于给定值k，则查找成功。（二）基本要求（1）了解查找表定义；（2）熟悉静态查找表的顺序存储结构；（3）熟悉顺序表的查找，理解有序表的查找和索引顺序表的查找的基本思路；（4）熟悉动态查找表的基本思路；（5）了解二叉排序树、平衡二叉树、B－树和B＋树的构造方法；（6）理解哈希查找的基本方法；（三）重点和难点（1）本章的重点:各种查找算法(静态、动态、哈希查找)及查找性能分析，深刻理解各种查找方法的优缺点及适用范围。（2）本章的难点:动态查找和哈希查找。（四）作业及课外学习要求：(1)若对大小均为n的有序顺序表和无序顺序表分别进行顺序查找，试在下列三种情况下分别讨论两者在等概率时的平均查找长度是否相同？(1)查找不成功，即表中没有关键字等于给定值K的记录；(2)查找成功，且表中只有一个关键字等于给定值K的记录；(3)查找成功，且表中有若干个关键字等于给定值K的记录，一次要查找求找出所有记录。此时的平均查找长度应考虑找到所有记录时所用的比较次数。(2)画出对长度为10的有序表进行折半查找的判定树，并求其等概率时查找成功的平均查找长度。(3)选取哈希函数H(k)=(3k)MOD11。用开放定址法处理冲突，di=I((7k)MOD10+1)(i=1,2,3,…)。试在0-10的散列地址空间中对关键字序列(22,41,53,46,30,13,01,67)构造哈希表，并求其等概率时查找成功的平均查找长度。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。第9章排序(10学时)（一）基本内容1基本概念关键字：数据元素中的某个数据项。如果某个数据项可以唯一地确定一个数据元素，就将其称为主关键字；否则，称为次关键字。排序：把一组无序的数据元素按照关键字值递增（或递减）地重新排列。如果排序依据的是主关键字，排序的结果将是唯一的。排序算法的稳定性：如果在待排序的记录序列中有多个数据元素的关键字值相同，经过排序后，这些数据元素的相对次序保持不变，则称这种排序算法是稳定的，否则称之为不稳定的。内部排序与外部排序：根据在排序过程中待排序的所有数据元素是否全部被放置在内存中，可将排序方法分为内部排序和外部排序两大类。内部排序是指在排序的整个过程中，待排序的所有数据元素全部被放置在内存中；外部排序是指由于待排序的数据元素个数太多，不能同时放置在内存，而需要将一部分数据元素放置在内存，另一部分数据元素放置在外设上，整个排序过程需要在内外存之间多次交换数据才能得到排序的结果。本章只讨论常用的内部排序方法。内部排序主要有5种方法：插入、交换、选择、归并和基数。排序算法的效率：评价排序算法的效率主要有两点：一是在数据量规模一定的条件下，算法执行所消耗的平均时间；二是执行算法所需要的辅助存储空间。2插入排序插入排序的主要思路是不断地将待排序的数值插入到有序段中，使有序段逐渐扩大，直至所有数值都进入有序段中位置。2.1直接插入排序直接插入排序的基本思想直接插入排序是一种比较简单的排序方法。它的基本思想是依次将记录序列中的每一个记录插入到有序段中，使有序段的长度不断地扩大。其具体的排序过程可以描述如下：首先将待排序记录序列中的第一个记录作为一个有序段，将记录序列中的第二个记录插入到上述有序段中形成由两个记录组成的有序段，再将记录序列中的第三个记录插入到这个有序段中，形成由三个记录组成的有序段，…依此类推，每一趟都是将一个记录插入到前面的有序段中，假设当前欲处理第i个记录，则应该将这个记录插入到由前i-1个记录组成的有序段中，从而形成一个由i个记录组成的按关键字值排列的有序序列，直到所有记录都插入到有序段中。一共需要经过n-1趟就可以将初始序列的n个记录重新排列成按关键字值大小排列的有序序列。当待排序记录较少时，排序速度较快，但是，当待排序的记录数量较大时，大量的比较和移动操作将使直接插入排序算法的效率降低；然而，当待排序的数据元素基本有序时，直接插入排序过程中的移动次数大大减少，从而效率会有所提高。插入排序是一种稳定的排序方法。2.2希尔排序希尔排序的基本思想希尔排序方法又称为缩小增量排序，其基本思想是将待排序的记录划分成几组，从而减少参与直接插入排序的数据量，当经过几次分组排序后，记录的排列已经基本有序，这个时候再对所有的记录实施直接插入排序。具体步骤可以描述如下：假设待排序的记录为n个，先取整数d<n，例如，取d=n/2（n/2表示不大于n/2的最大整数），将所有距离为d的记录构成一组，从而将整个待排序记录序列分割成为d个子序列，如图8-2所示，对每个分组分别进行直接插入排序，然后再缩小间隔d，例如，取d=d/2，重复上述的分组，再对每个分组分别进行直接插入排序，直到最后取d=1，即将所有记录放在一组进行一次直接插入排序，最终将所有记录重新排列成按关键字有序的序列。希尔排序适用于待排序的记录数目较大时，在此情况下，希尔排序方法一般要比直接插入排序方法快。同直接插入排序一样，希尔排序也只需要一个记录大小的辅助空间，用于暂存当前待插入的记录。希尔排序是一种不稳定的排序方法。3交换排序交换排序是指在排序过程中，主要是通过待排序记录序列中元素间关键字的比较，与存储位置的交换来达到排序目的一类排序方法。3.1冒泡排序冒泡排序是交换排序中一种简单的排序方法。它的基本思想是对所有相邻记录的关键字值进行比效，如果是逆顺（a[j]>a[j+1]），则将其交换，最终达到有序化。其处理过程为：（1）将整个待排序的记录序列划分成有序区和无序区，初始状态有序区为空，无序区包括所有待排序的记录。（2）对无序区从前向后依次将相邻记录的关键字进行比较，若逆序将其交换，从而使得关键字值小的记录向上“飘浮”（左移），关键字值大的记录好像石块，向下“堕落”（右移）。每经过一趟冒泡排序，都使无序区中关键字值最大的记录进入有序区，对于由n个记录组成的记录序列，最多经过n-1趟冒泡排序，就可以将这n个记录重新按关键字顺序排列。冒泡排序比较简单，当初始序列基本有序时，冒泡排序有较高的效率，反之效率较低；其次冒泡排序只需要一个记录的辅助空间，用来作为记录交换的中间暂存单元；冒泡排序是一种稳定的排序方法。3.2快速排序快速排序又称为分区交换排序。其基本思想是：首先将待排序记录序列中的所有记录作为当前待排序区域，从中任选取一个记录（比如，第一个记录），并以该记录的关键字值为基准，从位于待排序记录序列左右两端开始，逐渐向中间靠拢，交替与基准记录的关键字进行比较、交换，每次比较，若遇左侧记录的关键字值大于基准记录的关键字，则将其与基准记录交换，使其移到基准记录的右侧，若遇右侧记录的关键字值小于基准值，则将其与基准记录交换，使其移至基准记录的左侧，最后让基准记录到达它的最终位置，此时，基准记录将待排序记录分成了左右两个区域，位于基准记录左侧的记录都小于或等于基准记录的关键字，位于基准记录右侧的所有记录的关键字都大于或等于基准记录的关键字，这就是一趟快速排序；然后分别对左右两个新的待排序区域，重复上述一趟快速排序的过程，其结果分别让左右两个区域中的基准记录都到达它们的最终位置，同时将待排序记录序列分成更小的待排序区域，再次重复对每个区域进行一趟快束排序，直到每个区域只有一个记录为止，此时所有的记录都到达了它的最终位置，即整个待排序记录按关键值有序排列，至此排序结束。快速排序实质上是对冒泡排序的一种改进，它的效率与冒泡排序相比有很大地提高。到目前为止快速排序是平均速度最大的一种排序方法，但当原始记录排列基本有序或基本逆序时，每一趟的基准记录有可能只将其余记录分成一部分，这样就降低了时间效率，所以快速排序适用于原始记录排列杂乱无章的情况。快速排序是一种不稳定的排序，在递归调用时需要占据一定的存储空间用来保存每一层递归调用时的必要信息。4选择排序选择排序是指在排序过程序中，依次从待排序的记录序列中选择出关键字值最小的记录、关键字值次小的记录、并分别将它们定位到序列左侧的第1个位置、第二个位置、……，最后剩下一个关键字值最大的记录位于序列的最后一个位置，从而使待排序的记录序列成为按关键字值由小到大排列的的有序序列。4.1简单选择排序简单选择排序的基本思想是：每一趟在n-i+1(i=1,2,3,...,n-1)个记录中选取关键字最小的记录作为有序序列中的第i个记录。它的具体实现过程为：(1)将整个记录序列划分为有序区域和无序区域，有序区域位于最左端，无序区域位于右端，初始状态有序区域为空，无序区域含有待排序的所有n个记录。(2)设置一个整型变量index，用于记录在一趟的比较过程中，当前关键字值最小的记录位置。开始将它设定为当前无序区域的第一个位置，即假设这个位置的关键字最小，然后用它与无序区域中其他记录进行比较，若发现有比它的关键字还小的记录，就将index改为这个新的最小记录位置，随后再用a[index].key与后面的记录进行比较，并根据比较结果，随时修改index的值，一趟结束后index中保留的就是本趟选择的关键字最小的记录位置。(3)将index位置的记录交换到无序区域的第一个位置，使得有序区域扩展了一个记录，而无序区域减少了一个记录。不断重复(2)、(3)，直到无序区域剩下一个记录为止。此时所有的记录已经按关键字从小到大的顺序排列就位。简单选择排序算法简单，但是速度较慢，并且是一种不稳定的排序方法.，但在排序过程中只需要一个用来交换记录的暂存单元。4.2堆排序堆排序是另一种基于选择的排序方法。下面我们先介绍一下什么是堆？然后再介绍如何利用堆进行排序。堆定义：由n个元素组成的序列{k1，k2，……，kn-1，kn}，当且仅当满足如下关系时，称之为堆。ki≤k2iki≥k2i或ki≤k2i+1ki≥k2i+1其中i=1,2,3,…:[n/2]从堆的定义可以看出，若将堆用一棵完全二叉树表示，则根结点是当前堆中所有结点的最小者（或最大者）。堆排序的基本思想是：首先将待排序的记录序列构造一个堆，此时，选出了堆中所有记录的最小者或最大者，然后将它从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小（或次大）的记录，以此类推，直到堆中只有一个记录为止，每个记录出堆的顺序就是一个有序序列。在堆排序中，除建初堆以外，其余调整堆的过程最多需要比较树深次，因此，与简单选择排序相比时间效率提高了很多；另外，不管原始记录如何排列，堆排序的比较次数变化不大，所以说，堆排序对原始记录的排列状态并不敏感。堆排序是一种不稳定的。5归并排序归并排序是一种另一类排序方法。所谓归并是指将两个或两个以上的有序表合并成一个新的有序表。归并排序的基本思想是将一个具有n个待排序记录的序列看成是n个长度为1的有序列，然后进行两两归并，得到「n/2个长度为2的有序序列，再进行两两归并，得到「n/4个长度为4的有序序列，如此重复，直至得到一个长度为n的有序序列为止。它是一种稳定的排序方法。6基数排序基数排序是一种基于多关键字的排序方法。基数排序是借助于多关键字排序思想进行排序的一种排序方法。该方法将排序关键字K看作是由多个关键字组成的组合关键字，即K=k1k2…kd。每个关键字ki表示关键字的一位，其中k1为最高位，kd为最低位，d为关键字的位数。例如，对于关键字序列（101，203567，231，478，352），可以将每个关键K看成由三个单关键字组成，即K=k1k2k3，每个关键字的取值范围为0≤ki≤9，所以每个关键字可取值的数目为10，通常将关键字取值的数目称为基数，用符号r表示，在这个例子中r=10。对于关键字序列（AB,BD,ED）可以将每个关键字看成是由二个单字母关键字组成的复合关键字，并且每个关键字的取值范围为“A~Z”，所以关键字的基数r=26。从基数排序的算法中可以看到：基数排序适用于待排序的记录数目较多，但其关键字位数较少，且关键字每一位的基数相同的情况。若待排序记录的关键字有d位就需要进行d次“分配”与“收集”，即共执行d趟，因此，若d值较大，基数排序的时间效率就会随之降低。基数排序是一种稳定的排序方法。（二）基本要求(1)深刻理解排序的定义和各种排序方法的特点，并能加以灵活运用。(2)了解各种排序方法的排序过程、基本思想、算法特点及其依据的原则。(3)掌握各种排序方法的时间复杂度的分析方法。能从“关键字间的比较次数”分析排序算法的平均情况和最坏情况的时间性能。(4)理解排序方法“稳定”或“不稳定”的含义，弄清楚在什么情况下要求应用的排序方法必须是稳定的。(5)了解“表排序”和“地址排序”的过程及其适用场合。（三）重点和难点重点：(1)希尔排序、快速排序、堆排序和归并排序等高效方法是本章的重点；(2)各种排序方法的排序过程、基本思想；(3)各种排序方法的时间复杂度的分析方法；(4)判断某种排序方法是稳定还是不稳定的。难点：掌握各种高效排序方法的排序过程、基本思想。（四）作业及课外学习要求：(1)以关键码序列(503,807,512,061,908,170,897,275,653,426)，写出每一趟排序结束时的关键码状态。(1)直接插入排序；(2)希尔排序(增量d[1]=5)；(3)快速排序；(4)堆排序；(5)归并排序；(6)基数排序。(2)试问在1题中所列各种排序方法，哪些是稳定的？哪些是不稳定的？并为每一种不稳定的排序方法举出一个不稳定的实例。(3)编写一个双向起泡的排序算法，即相邻两遍向相反方向起泡。(4)编写算法，对n个关键字取整数值的记录序列进行整理，以使所有关键字为负值的记录排在关键字为非负值的记录之前，要求：(1)采用顺序存储结构，至多使用一个记录的辅助空间；(2)算法的时间复杂度为O(n)；(3)讨论算法中记录的最大移动次数。通过期末笔试的考试来对本章知识点的掌握情况进行考核，即对“毕业要求1工程知识”中的“指标点1-3掌握软件工程专业基本理论，以及基本分析与设计方法，用于解决复杂软件工程问题”，“毕业要求2问题分析”中的“指标点2-2具备对复杂工程问题进行识别和判断，并结合专业知识进行有效分解；具备对分解后的复杂工程问题进行表达和建模的能力”和“指标点2-3能够对于模型的正确性进行严谨的推理，并能够给出解”的指标达成度进行评估。